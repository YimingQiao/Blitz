// The decompression process class header

#ifndef DECOMPRESSION_H
#define DECOMPRESSION_H

#include <fstream>
#include <memory>
#include <string>
#include <vector>

#include "base.h"
#include "data_io.h"
#include "index.h"
#include "model.h"

namespace db_compress {

/**
 * It is used to recovered information from compressed binary file.
 * First, it needs to know where to start decompression; Then, decompress next
 * tuple with ReadNextTuple function until all needed tuples have been given.
 */
class RelationDecompressor {
 public:
  int num_total_tuples_;

  /**
   * Create a decompressor.
   *
   * @param compressed_file_name compressed file address
   * @param schema schema contains attributes types and ordering
   * @param start_tuple it indicates where to start decompress dataset
   * @param decompress_num in indicates how many tuples to be decompress
   * @param block_size once decompressed tuple number is larger than block size,
   * decoder need initialization.
   */
  RelationDecompressor(const char *compressedFileName, Schema schema, int block_size);

  /**
   * Init a decompressor. including loading squid models from disks and finding
   * the position of decompression starts (random access).
   */
  void Init();

  /**
   * Random Access. Locate tuple position.
   *
   * @param tuple_idx index of accessed tuple
   */
  void LocateTuple(int tuple_idx);

  /**
   * Decompress next tuple, existence of next tuple should be checked before
   * calling this function.
   *
   * @param[out] tuple decompressed result
   */
  void ReadNextTuple(AttrVector *tuple);

  /**
   * Check if next tuple is existed.
   *
   * @return return true if next tuple exists; or return false
   */
  bool HasNext() const { return num_converted_tuples_ < num_todo_tuples_; }

  /**
   * Get the index of last decompressed tuple in a dataset
   *
   * @return return the index of last tuple
   */
  int GetCurrentPosition() const { return tuple_idx_ + num_converted_tuples_ - 1; }

  /**
   * Get number of unwanted tuples
   */
  int GetNumUnwantedTuples() { return num_unwanted_tuples_; }

 private:
  Schema schema_;
  IndexReader index_reader_;
  ByteReader byte_reader_;

  int num_converted_tuples_, num_todo_tuples_;

  // where to start decompress, how many tuples wanted, and how many tuples we do not need but have
  // to decompress due to block.
  int tuple_idx_, num_wanted_tuples_, num_unwanted_tuples_;

  std::vector<std::unique_ptr<SquIDModel> > model_;
  std::vector<size_t> attr_order_;
  Decoder decoder_;

  // bit buffer: it is used to store (used but not necessary) bits
  std::vector<bool> bit_buffer_;
  int bit_buffer_index_;

  int data_pos_;
  uint32_t num_bytes_;
  unsigned char num_bits_;

  /**
   * Initialize a unit probability interval with [0, 1] for each tuple.
   *
   * @param PIb
   */
  void InitPIb(UnitProbInterval &PIb);

  /**
   * Since each time decoder reads one byte, so there is unused but unnecessary
   * bits. This function emits the additional bits for future use, a bit buffer
   * is set to store these bits.
   *
   * @param PIb a unit probability interval. Each time we read a bit, update it:
   * if bit is zero, replace unit probability interval with left part; otherwise
   * choose the right.
   * @param PIt a probability interval generated by branch chosen.
   */
  void EmitAdditionBits(UnitProbInterval &PIb, const ProbInterval &PIt);
};

}  // namespace db_compress

#endif
